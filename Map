// let pieces = [
//   [[1, 1],
//    [1, 1]],
//   [[1, 0],
//    [1, 1]],
//   [[1, 0],
//    [1, 1],
//    [1, 0]],
//   [[0, 1, 0],
//    [1, 1, 1],
//    [0, 1, 0]],
//   [[1, 0, 0],
//    [1, 1, 1]]
// ];

// function flipX(piece) {
//   const w = piece[0].length;
//   const h = piece.length;
//   const answer = Array(h).fill().map(() => Array(w).fill(0));
//   for (let j = 0; j < h; j++) {
//     for (let i = 0; i < w; i++) {
//       answer[j][i] = piece[j][w-i-1];
//     }
//   }
//   return answer;
// }

// function flipY(piece) {
//   const w = piece[0].length;
//   const h = piece.length;
//   const answer = Array(h).fill().map(() => Array(w).fill(0));
//   for (let j = 0; j < h; j++) {
//     for (let i = 0; i < w; i++) {
//       answer[j][i] = piece[h-j-1][i];
//     }
//   }
//   return answer;
// }

// function transpose(piece) {
//   const w = piece[0].length;
//   const h = piece.length;
//   const answer = Array(w).fill().map(() => Array(h).fill(0));
//   for (let j = 0; j < w; j++) {
//     for (let i = 0; i < h; i++) {
//       answer[j][i] = piece[i][j];
//     }
//   }
//   return answer;
// }

// class PieceObj {
//   constructor(piece, x, y) {
//     this.piece = piece;
//     this.x = x;
//     this.y = y;
//   }
// }

// function copyGrid(grid) {
//   const answer = [];
//   for (const row of grid) {
//     answer.push(row.slice());
//   }
//   return answer;
// }

// function fit(pieceObj) {
//   if (pieceObj.piece) {
//     const oldGrid = copyGrid(grid);
//     const piece = pieceObj.piece;
//     const w = piece[0].length;
//     const h = piece.length;
//     if (pieceObj.y < 0 || pieceObj.x > cols-w || pieceObj.y > rows-h || pieceObj.x < 0) {
//       return false;
//     }
//     for (let j = 0; j < h; j++) {
//       for (let i = 0; i < w; i++) {
//         const x = i + pieceObj.x;
//         const y = j + pieceObj.y;
//         if (grid[y][x] <= 0 && piece[j][i] > 0) {
//           grid[y][x] = 1;
//         } else if (grid[y][x] > 0 && piece[j][i] > 0) {
//           grid = oldGrid;
//           return false;
//         }
//       }
//     }
//     return true;
//   } else {
//     return false;
//   }
// }

// function generate() {
//   // cols, rows
//   const genPieces = [];
//   const origin = {};
//   let rotatedPieces = pieces.slice();
//   rotatedPieces = rotatedPieces.concat(rotatedPieces.map(x => flipX(x)));
//   rotatedPieces = rotatedPieces.concat(rotatedPieces.map(x => flipY(x)));
//   rotatedPieces = rotatedPieces.concat(rotatedPieces.map(x => transpose(x)));
  
//   for (let j = 0; j < rows; j++) {
//     for (let i = 0; i < cols; i++) {
//       if (grid[j][i] <= 0) {
//         rotatedPieces = shuffle(rotatedPieces);
        
//         let filtered = [];
//         for (const p of rotatedPieces) {
//           const w = p[0].length;
//           const h = p.length;
          
//           const oldGrid = copyGrid(grid);
//           const fitted = fit(new PieceObj(p, i, j));
//           grid = oldGrid;
//           if (fitted) {
//             filtered.push(p);
//           }
//         }
        
//         filtered.shift();
//         try {
//           const piece = random(filtered);
//           fit(new PieceObj(piece, i, j));
//         } catch (err) {  }
//       }
//     }
//   }
// }

function generate() {
  let x = random(1, cols/3) & 11111110 ^ 1;
  let y = 1;
  grid[y][x] = 1;
  grid[y][cols - 1 - x] = 1;
  
  let hack = 0;
  let count = 0;
  const stack = [];
  while (true) {
    const savedX = x;
    const savedY = y;
    switch (random(4) | 0) {
      case 0:
        y -= 2;
        break;
      case 1:
        x += 2;
        if (x >= cols) {
          x -= cols;
        }
        break;
      case 2:
        y += 2;
        break;
      case 3:
        x -= 2;
        if (x < 0) {
          x += cols;
        }
        break;
    }
    if (y < 1 || y >= rows-1 || grid[y][x] > 0) {
      if (hack < 10000) {
        x = savedX;
        y = savedY;
        hack++;
      } else {
        try {
          const pos = stack.pop();
          x = pos[0];
          y = pos[1];
          hack = 0;
        } catch (err) {
          break;
        }
      }
    } else {
      const middleX = lerp(savedX, x, 0.5);
      const middleY = lerp(savedY, y, 0.5);
      grid[middleY][middleX] = 1;
      grid[y][x] = 1;
      grid[middleY][cols - 1 - middleX] = 1;
      grid[y][cols - 1 - x] = 1;
      stack.push([x, y]);
      hack = 0;
    }
  }
}
